// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
//////// DO NOT CHANGE THIS FILE! ////////
// Change the json schema instead

#![allow(dead_code)]

use wasmlib::*;

use crate::consts::*;
use crate::params::*;
use crate::results::*;

pub struct Erc20Func {
    sc: ScContractFunc,
}

impl Erc20Func {
    pub fn new(ctx: &ScFuncContext) -> Erc20Func {
        Erc20Func { sc: ScContractFunc::new(ctx, HSC_NAME) }
    }

    pub fn delay(&mut self, seconds: i64) -> &mut Erc20Func {
        self.sc.delay(seconds);
        self
    }

    pub fn of_contract(&mut self, contract: ScHname) -> &mut Erc20Func {
        self.sc.of_contract(contract);
        self
    }

    pub fn post(&mut self) -> &mut Erc20Func {
        self.sc.post();
        self
    }

    pub fn post_to_chain(&mut self, chain_id: ScChainId) -> &mut Erc20Func {
        self.sc.post_to_chain(chain_id);
        self
    }

    pub fn approve(&mut self, params: MutableFuncApproveParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_APPROVE, params.id, Some(transfer));
    }

    pub fn init(&mut self, params: MutableFuncInitParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_INIT, params.id, Some(transfer));
    }

    pub fn transfer(&mut self, params: MutableFuncTransferParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_TRANSFER, params.id, Some(transfer));
    }

    pub fn transfer_from(&mut self, params: MutableFuncTransferFromParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_TRANSFER_FROM, params.id, Some(transfer));
    }

    pub fn allowance(&mut self, params: MutableViewAllowanceParams) -> ImmutableViewAllowanceResults {
        self.sc.run(HVIEW_ALLOWANCE, params.id, None);
        ImmutableViewAllowanceResults { id: self.sc.result_map_id() }
    }

    pub fn balance_of(&mut self, params: MutableViewBalanceOfParams) -> ImmutableViewBalanceOfResults {
        self.sc.run(HVIEW_BALANCE_OF, params.id, None);
        ImmutableViewBalanceOfResults { id: self.sc.result_map_id() }
    }

    pub fn total_supply(&mut self) -> ImmutableViewTotalSupplyResults {
        self.sc.run(HVIEW_TOTAL_SUPPLY, 0, None);
        ImmutableViewTotalSupplyResults { id: self.sc.result_map_id() }
    }
}

pub struct Erc20View {
    sc: ScContractView,
}

impl Erc20View {
    pub fn new(ctx: &ScViewContext) -> Erc20View {
        Erc20View { sc: ScContractView::new(ctx, HSC_NAME) }
    }

    pub fn of_contract(&mut self, contract: ScHname) -> &mut Erc20View {
        self.sc.of_contract(contract);
        self
    }

    pub fn allowance(&mut self, params: MutableViewAllowanceParams) -> ImmutableViewAllowanceResults {
        self.sc.run(HVIEW_ALLOWANCE, params.id);
        ImmutableViewAllowanceResults { id: self.sc.result_map_id() }
    }

    pub fn balance_of(&mut self, params: MutableViewBalanceOfParams) -> ImmutableViewBalanceOfResults {
        self.sc.run(HVIEW_BALANCE_OF, params.id);
        ImmutableViewBalanceOfResults { id: self.sc.result_map_id() }
    }

    pub fn total_supply(&mut self) -> ImmutableViewTotalSupplyResults {
        self.sc.run(HVIEW_TOTAL_SUPPLY, 0);
        ImmutableViewTotalSupplyResults { id: self.sc.result_map_id() }
    }
}
