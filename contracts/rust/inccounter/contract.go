// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
//////// DO NOT CHANGE THIS FILE! ////////
// Change the json schema instead

package inccounter

import "github.com/iotaledger/wasplib/packages/vm/wasmlib"

type CallIncrementCall struct {
	Func *wasmlib.ScFunc
}

func NewCallIncrementCall(ctx wasmlib.ScFuncContext) *CallIncrementCall {
	return &CallIncrementCall{Func: wasmlib.NewScFunc(HScName, HFuncCallIncrement)}
}

type CallIncrementRecurse5xCall struct {
	Func *wasmlib.ScFunc
}

func NewCallIncrementRecurse5xCall(ctx wasmlib.ScFuncContext) *CallIncrementRecurse5xCall {
	return &CallIncrementRecurse5xCall{Func: wasmlib.NewScFunc(HScName, HFuncCallIncrementRecurse5x)}
}

type EndlessLoopCall struct {
	Func *wasmlib.ScFunc
}

func NewEndlessLoopCall(ctx wasmlib.ScFuncContext) *EndlessLoopCall {
	return &EndlessLoopCall{Func: wasmlib.NewScFunc(HScName, HFuncEndlessLoop)}
}

type IncrementCall struct {
	Func *wasmlib.ScFunc
}

func NewIncrementCall(ctx wasmlib.ScFuncContext) *IncrementCall {
	return &IncrementCall{Func: wasmlib.NewScFunc(HScName, HFuncIncrement)}
}

type InitCall struct {
	Func   *wasmlib.ScFunc
	Params MutableInitParams
}

func NewInitCall(ctx wasmlib.ScFuncContext) *InitCall {
	f := &InitCall{Func: wasmlib.NewScFunc(HScName, HFuncInit)}
	f.Func.SetPtrs(&f.Params.id, nil)
	return f
}

type LocalStateInternalCallCall struct {
	Func *wasmlib.ScFunc
}

func NewLocalStateInternalCallCall(ctx wasmlib.ScFuncContext) *LocalStateInternalCallCall {
	return &LocalStateInternalCallCall{Func: wasmlib.NewScFunc(HScName, HFuncLocalStateInternalCall)}
}

type LocalStatePostCall struct {
	Func *wasmlib.ScFunc
}

func NewLocalStatePostCall(ctx wasmlib.ScFuncContext) *LocalStatePostCall {
	return &LocalStatePostCall{Func: wasmlib.NewScFunc(HScName, HFuncLocalStatePost)}
}

type LocalStateSandboxCallCall struct {
	Func *wasmlib.ScFunc
}

func NewLocalStateSandboxCallCall(ctx wasmlib.ScFuncContext) *LocalStateSandboxCallCall {
	return &LocalStateSandboxCallCall{Func: wasmlib.NewScFunc(HScName, HFuncLocalStateSandboxCall)}
}

type PostIncrementCall struct {
	Func *wasmlib.ScFunc
}

func NewPostIncrementCall(ctx wasmlib.ScFuncContext) *PostIncrementCall {
	return &PostIncrementCall{Func: wasmlib.NewScFunc(HScName, HFuncPostIncrement)}
}

type RepeatManyCall struct {
	Func   *wasmlib.ScFunc
	Params MutableRepeatManyParams
}

func NewRepeatManyCall(ctx wasmlib.ScFuncContext) *RepeatManyCall {
	f := &RepeatManyCall{Func: wasmlib.NewScFunc(HScName, HFuncRepeatMany)}
	f.Func.SetPtrs(&f.Params.id, nil)
	return f
}

type TestLeb128Call struct {
	Func *wasmlib.ScFunc
}

func NewTestLeb128Call(ctx wasmlib.ScFuncContext) *TestLeb128Call {
	return &TestLeb128Call{Func: wasmlib.NewScFunc(HScName, HFuncTestLeb128)}
}

type WhenMustIncrementCall struct {
	Func   *wasmlib.ScFunc
	Params MutableWhenMustIncrementParams
}

func NewWhenMustIncrementCall(ctx wasmlib.ScFuncContext) *WhenMustIncrementCall {
	f := &WhenMustIncrementCall{Func: wasmlib.NewScFunc(HScName, HFuncWhenMustIncrement)}
	f.Func.SetPtrs(&f.Params.id, nil)
	return f
}

type GetCounterCall struct {
	Func    *wasmlib.ScView
	Results ImmutableGetCounterResults
}

func NewGetCounterCall(ctx wasmlib.ScFuncContext) *GetCounterCall {
	f := &GetCounterCall{Func: wasmlib.NewScView(HScName, HViewGetCounter)}
	f.Func.SetPtrs(nil, &f.Results.id)
	return f
}

func NewGetCounterCallFromView(ctx wasmlib.ScViewContext) *GetCounterCall {
	return NewGetCounterCall(wasmlib.ScFuncContext{})
}
