// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

package inccounter

import "github.com/iotaledger/wasplib/packages/vm/wasmlib"

type CallIncrementCall struct {
	Func *wasmlib.ScFunc
}

type CallIncrementRecurse5xCall struct {
	Func *wasmlib.ScFunc
}

type EndlessLoopCall struct {
	Func *wasmlib.ScFunc
}

type IncrementCall struct {
	Func *wasmlib.ScFunc
}

type InitCall struct {
	Func   *wasmlib.ScInitFunc
	Params MutableInitParams
}

type LocalStateInternalCallCall struct {
	Func *wasmlib.ScFunc
}

type LocalStatePostCall struct {
	Func *wasmlib.ScFunc
}

type LocalStateSandboxCallCall struct {
	Func *wasmlib.ScFunc
}

type PostIncrementCall struct {
	Func *wasmlib.ScFunc
}

type RepeatManyCall struct {
	Func   *wasmlib.ScFunc
	Params MutableRepeatManyParams
}

type TestLeb128Call struct {
	Func *wasmlib.ScFunc
}

type WhenMustIncrementCall struct {
	Func   *wasmlib.ScFunc
	Params MutableWhenMustIncrementParams
}

type GetCounterCall struct {
	Func    *wasmlib.ScView
	Results ImmutableGetCounterResults
}

type Funcs struct{}

var ScFuncs Funcs

func (sc Funcs) CallIncrement(ctx wasmlib.ScFuncCallContext) *CallIncrementCall {
	return &CallIncrementCall{Func: wasmlib.NewScFunc(HScName, HFuncCallIncrement)}
}

func (sc Funcs) CallIncrementRecurse5x(ctx wasmlib.ScFuncCallContext) *CallIncrementRecurse5xCall {
	return &CallIncrementRecurse5xCall{Func: wasmlib.NewScFunc(HScName, HFuncCallIncrementRecurse5x)}
}

func (sc Funcs) EndlessLoop(ctx wasmlib.ScFuncCallContext) *EndlessLoopCall {
	return &EndlessLoopCall{Func: wasmlib.NewScFunc(HScName, HFuncEndlessLoop)}
}

func (sc Funcs) Increment(ctx wasmlib.ScFuncCallContext) *IncrementCall {
	return &IncrementCall{Func: wasmlib.NewScFunc(HScName, HFuncIncrement)}
}

func (sc Funcs) Init(ctx wasmlib.ScFuncCallContext) *InitCall {
	f := &InitCall{Func: wasmlib.NewScInitFunc(HScName, HFuncInit, ctx, keyMap[:], idxMap[:])}
	f.Func.SetPtrs(&f.Params.id, nil)
	return f
}

func (sc Funcs) LocalStateInternalCall(ctx wasmlib.ScFuncCallContext) *LocalStateInternalCallCall {
	return &LocalStateInternalCallCall{Func: wasmlib.NewScFunc(HScName, HFuncLocalStateInternalCall)}
}

func (sc Funcs) LocalStatePost(ctx wasmlib.ScFuncCallContext) *LocalStatePostCall {
	return &LocalStatePostCall{Func: wasmlib.NewScFunc(HScName, HFuncLocalStatePost)}
}

func (sc Funcs) LocalStateSandboxCall(ctx wasmlib.ScFuncCallContext) *LocalStateSandboxCallCall {
	return &LocalStateSandboxCallCall{Func: wasmlib.NewScFunc(HScName, HFuncLocalStateSandboxCall)}
}

func (sc Funcs) PostIncrement(ctx wasmlib.ScFuncCallContext) *PostIncrementCall {
	return &PostIncrementCall{Func: wasmlib.NewScFunc(HScName, HFuncPostIncrement)}
}

func (sc Funcs) RepeatMany(ctx wasmlib.ScFuncCallContext) *RepeatManyCall {
	f := &RepeatManyCall{Func: wasmlib.NewScFunc(HScName, HFuncRepeatMany)}
	f.Func.SetPtrs(&f.Params.id, nil)
	return f
}

func (sc Funcs) TestLeb128(ctx wasmlib.ScFuncCallContext) *TestLeb128Call {
	return &TestLeb128Call{Func: wasmlib.NewScFunc(HScName, HFuncTestLeb128)}
}

func (sc Funcs) WhenMustIncrement(ctx wasmlib.ScFuncCallContext) *WhenMustIncrementCall {
	f := &WhenMustIncrementCall{Func: wasmlib.NewScFunc(HScName, HFuncWhenMustIncrement)}
	f.Func.SetPtrs(&f.Params.id, nil)
	return f
}

func (sc Funcs) GetCounter(ctx wasmlib.ScViewCallContext) *GetCounterCall {
	f := &GetCounterCall{Func: wasmlib.NewScView(HScName, HViewGetCounter)}
	f.Func.SetPtrs(nil, &f.Results.id)
	return f
}
