// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
//////// DO NOT CHANGE THIS FILE! ////////
// Change the json schema instead

#![allow(dead_code)]

use wasmlib::*;

use crate::consts::*;
use crate::params::*;
use crate::results::*;

pub struct IncCounterFunc {
    sc: ScContractFunc,
}

impl IncCounterFunc {
    pub fn new(ctx: &ScFuncContext) -> IncCounterFunc {
        IncCounterFunc { sc: ScContractFunc::new(ctx, HSC_NAME) }
    }

    pub fn delay(&mut self, seconds: i64) -> &mut IncCounterFunc {
        self.sc.delay(seconds);
        self
    }

    pub fn of_contract(&mut self, contract: ScHname) -> &mut IncCounterFunc {
        self.sc.of_contract(contract);
        self
    }

    pub fn post(&mut self) -> &mut IncCounterFunc {
        self.sc.post();
        self
    }

    pub fn post_to_chain(&mut self, chain_id: ScChainId) -> &mut IncCounterFunc {
        self.sc.post_to_chain(chain_id);
        self
    }

    pub fn call_increment(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_CALL_INCREMENT, 0, Some(transfer));
    }

    pub fn call_increment_recurse5x(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_CALL_INCREMENT_RECURSE5X, 0, Some(transfer));
    }

    pub fn endless_loop(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_ENDLESS_LOOP, 0, Some(transfer));
    }

    pub fn increment(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_INCREMENT, 0, Some(transfer));
    }

    pub fn init(&mut self, params: MutableFuncInitParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_INIT, params.id, Some(transfer));
    }

    pub fn local_state_internal_call(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_LOCAL_STATE_INTERNAL_CALL, 0, Some(transfer));
    }

    pub fn local_state_post(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_LOCAL_STATE_POST, 0, Some(transfer));
    }

    pub fn local_state_sandbox_call(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_LOCAL_STATE_SANDBOX_CALL, 0, Some(transfer));
    }

    pub fn post_increment(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_POST_INCREMENT, 0, Some(transfer));
    }

    pub fn repeat_many(&mut self, params: MutableFuncRepeatManyParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_REPEAT_MANY, params.id, Some(transfer));
    }

    pub fn test_leb128(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_TEST_LEB128, 0, Some(transfer));
    }

    pub fn when_must_increment(&mut self, params: MutableFuncWhenMustIncrementParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_WHEN_MUST_INCREMENT, params.id, Some(transfer));
    }

    pub fn get_counter(&mut self) -> ImmutableViewGetCounterResults {
        self.sc.run(HVIEW_GET_COUNTER, 0, None);
        ImmutableViewGetCounterResults { id: self.sc.result_map_id() }
    }
}

pub struct IncCounterView {
    sc: ScContractView,
}

impl IncCounterView {
    pub fn new(ctx: &ScViewContext) -> IncCounterView {
        IncCounterView { sc: ScContractView::new(ctx, HSC_NAME) }
    }

    pub fn of_contract(&mut self, contract: ScHname) -> &mut IncCounterView {
        self.sc.of_contract(contract);
        self
    }

    pub fn get_counter(&mut self) -> ImmutableViewGetCounterResults {
        self.sc.run(HVIEW_GET_COUNTER, 0);
        ImmutableViewGetCounterResults { id: self.sc.result_map_id() }
    }
}
