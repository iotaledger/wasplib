// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
//////// DO NOT CHANGE THIS FILE! ////////
// Change the json schema instead

#![allow(dead_code)]

use wasmlib::*;

use crate::consts::*;
use crate::params::*;
use crate::results::*;

pub struct TestCoreFunc {
    sc: ScContractFunc,
}

impl TestCoreFunc {
    pub fn new(ctx: &ScFuncContext) -> TestCoreFunc {
        TestCoreFunc { sc: ScContractFunc::new(ctx, HSC_NAME) }
    }

    pub fn delay(&mut self, seconds: i64) -> &mut TestCoreFunc {
        self.sc.delay(seconds);
        self
    }

    pub fn of_contract(&mut self, contract: ScHname) -> &mut TestCoreFunc {
        self.sc.of_contract(contract);
        self
    }

    pub fn post(&mut self) -> &mut TestCoreFunc {
        self.sc.post();
        self
    }

    pub fn post_to_chain(&mut self, chain_id: ScChainId) -> &mut TestCoreFunc {
        self.sc.post_to_chain(chain_id);
        self
    }

    pub fn call_on_chain(&mut self, params: MutableFuncCallOnChainParams, transfer: ScTransfers) -> ImmutableFuncCallOnChainResults {
        self.sc.run(HFUNC_CALL_ON_CHAIN, params.id, Some(transfer));
        ImmutableFuncCallOnChainResults { id: self.sc.result_map_id() }
    }

    pub fn check_context_from_full_ep(&mut self, params: MutableFuncCheckContextFromFullEPParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_CHECK_CONTEXT_FROM_FULL_EP, params.id, Some(transfer));
    }

    pub fn do_nothing(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_DO_NOTHING, 0, Some(transfer));
    }

    pub fn get_minted_supply(&mut self, transfer: ScTransfers) -> ImmutableFuncGetMintedSupplyResults {
        self.sc.run(HFUNC_GET_MINTED_SUPPLY, 0, Some(transfer));
        ImmutableFuncGetMintedSupplyResults { id: self.sc.result_map_id() }
    }

    pub fn inc_counter(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_INC_COUNTER, 0, Some(transfer));
    }

    pub fn init(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_INIT, 0, Some(transfer));
    }

    pub fn pass_types_full(&mut self, params: MutableFuncPassTypesFullParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_PASS_TYPES_FULL, params.id, Some(transfer));
    }

    pub fn run_recursion(&mut self, params: MutableFuncRunRecursionParams, transfer: ScTransfers) -> ImmutableFuncRunRecursionResults {
        self.sc.run(HFUNC_RUN_RECURSION, params.id, Some(transfer));
        ImmutableFuncRunRecursionResults { id: self.sc.result_map_id() }
    }

    pub fn send_to_address(&mut self, params: MutableFuncSendToAddressParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_SEND_TO_ADDRESS, params.id, Some(transfer));
    }

    pub fn set_int(&mut self, params: MutableFuncSetIntParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_SET_INT, params.id, Some(transfer));
    }

    pub fn test_call_panic_full_ep(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_TEST_CALL_PANIC_FULL_EP, 0, Some(transfer));
    }

    pub fn test_call_panic_view_ep_from_full(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_TEST_CALL_PANIC_VIEW_EP_FROM_FULL, 0, Some(transfer));
    }

    pub fn test_chain_owner_id_full(&mut self, transfer: ScTransfers) -> ImmutableFuncTestChainOwnerIDFullResults {
        self.sc.run(HFUNC_TEST_CHAIN_OWNER_ID_FULL, 0, Some(transfer));
        ImmutableFuncTestChainOwnerIDFullResults { id: self.sc.result_map_id() }
    }

    pub fn test_event_log_deploy(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_TEST_EVENT_LOG_DEPLOY, 0, Some(transfer));
    }

    pub fn test_event_log_event_data(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_TEST_EVENT_LOG_EVENT_DATA, 0, Some(transfer));
    }

    pub fn test_event_log_generic_data(&mut self, params: MutableFuncTestEventLogGenericDataParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_TEST_EVENT_LOG_GENERIC_DATA, params.id, Some(transfer));
    }

    pub fn test_panic_full_ep(&mut self, transfer: ScTransfers) {
        self.sc.run(HFUNC_TEST_PANIC_FULL_EP, 0, Some(transfer));
    }

    pub fn withdraw_to_chain(&mut self, params: MutableFuncWithdrawToChainParams, transfer: ScTransfers) {
        self.sc.run(HFUNC_WITHDRAW_TO_CHAIN, params.id, Some(transfer));
    }

    pub fn check_context_from_view_ep(&mut self, params: MutableViewCheckContextFromViewEPParams) {
        self.sc.run(HVIEW_CHECK_CONTEXT_FROM_VIEW_EP, params.id, None);
    }

    pub fn fibonacci(&mut self, params: MutableViewFibonacciParams) -> ImmutableViewFibonacciResults {
        self.sc.run(HVIEW_FIBONACCI, params.id, None);
        ImmutableViewFibonacciResults { id: self.sc.result_map_id() }
    }

    pub fn get_counter(&mut self) -> ImmutableViewGetCounterResults {
        self.sc.run(HVIEW_GET_COUNTER, 0, None);
        ImmutableViewGetCounterResults { id: self.sc.result_map_id() }
    }

    pub fn get_int(&mut self, params: MutableViewGetIntParams) {
        self.sc.run(HVIEW_GET_INT, params.id, None);
    }

    pub fn just_view(&mut self) {
        self.sc.run(HVIEW_JUST_VIEW, 0, None);
    }

    pub fn pass_types_view(&mut self, params: MutableViewPassTypesViewParams) {
        self.sc.run(HVIEW_PASS_TYPES_VIEW, params.id, None);
    }

    pub fn test_call_panic_view_ep_from_view(&mut self) {
        self.sc.run(HVIEW_TEST_CALL_PANIC_VIEW_EP_FROM_VIEW, 0, None);
    }

    pub fn test_chain_owner_id_view(&mut self) -> ImmutableViewTestChainOwnerIDViewResults {
        self.sc.run(HVIEW_TEST_CHAIN_OWNER_ID_VIEW, 0, None);
        ImmutableViewTestChainOwnerIDViewResults { id: self.sc.result_map_id() }
    }

    pub fn test_panic_view_ep(&mut self) {
        self.sc.run(HVIEW_TEST_PANIC_VIEW_EP, 0, None);
    }

    pub fn test_sandbox_call(&mut self) -> ImmutableViewTestSandboxCallResults {
        self.sc.run(HVIEW_TEST_SANDBOX_CALL, 0, None);
        ImmutableViewTestSandboxCallResults { id: self.sc.result_map_id() }
    }
}

pub struct TestCoreView {
    sc: ScContractView,
}

impl TestCoreView {
    pub fn new(ctx: &ScViewContext) -> TestCoreView {
        TestCoreView { sc: ScContractView::new(ctx, HSC_NAME) }
    }

    pub fn of_contract(&mut self, contract: ScHname) -> &mut TestCoreView {
        self.sc.of_contract(contract);
        self
    }

    pub fn check_context_from_view_ep(&mut self, params: MutableViewCheckContextFromViewEPParams) {
        self.sc.run(HVIEW_CHECK_CONTEXT_FROM_VIEW_EP, params.id);
    }

    pub fn fibonacci(&mut self, params: MutableViewFibonacciParams) -> ImmutableViewFibonacciResults {
        self.sc.run(HVIEW_FIBONACCI, params.id);
        ImmutableViewFibonacciResults { id: self.sc.result_map_id() }
    }

    pub fn get_counter(&mut self) -> ImmutableViewGetCounterResults {
        self.sc.run(HVIEW_GET_COUNTER, 0);
        ImmutableViewGetCounterResults { id: self.sc.result_map_id() }
    }

    pub fn get_int(&mut self, params: MutableViewGetIntParams) {
        self.sc.run(HVIEW_GET_INT, params.id);
    }

    pub fn just_view(&mut self) {
        self.sc.run(HVIEW_JUST_VIEW, 0);
    }

    pub fn pass_types_view(&mut self, params: MutableViewPassTypesViewParams) {
        self.sc.run(HVIEW_PASS_TYPES_VIEW, params.id);
    }

    pub fn test_call_panic_view_ep_from_view(&mut self) {
        self.sc.run(HVIEW_TEST_CALL_PANIC_VIEW_EP_FROM_VIEW, 0);
    }

    pub fn test_chain_owner_id_view(&mut self) -> ImmutableViewTestChainOwnerIDViewResults {
        self.sc.run(HVIEW_TEST_CHAIN_OWNER_ID_VIEW, 0);
        ImmutableViewTestChainOwnerIDViewResults { id: self.sc.result_map_id() }
    }

    pub fn test_panic_view_ep(&mut self) {
        self.sc.run(HVIEW_TEST_PANIC_VIEW_EP, 0);
    }

    pub fn test_sandbox_call(&mut self) -> ImmutableViewTestSandboxCallResults {
        self.sc.run(HVIEW_TEST_SANDBOX_CALL, 0);
        ImmutableViewTestSandboxCallResults { id: self.sc.result_map_id() }
    }
}
