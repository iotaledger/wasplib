// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
//////// DO NOT CHANGE THIS FILE! ////////
// Change the json schema instead

package fairroulette

import "github.com/iotaledger/wasplib/packages/vm/wasmlib"

func OnLoad() {
	exports := wasmlib.NewScExports()
	exports.AddFunc(FuncLockBets, funcLockBetsThunk)
	exports.AddFunc(FuncPayWinners, funcPayWinnersThunk)
	exports.AddFunc(FuncPlaceBet, funcPlaceBetThunk)
	exports.AddFunc(FuncPlayPeriod, funcPlayPeriodThunk)
	exports.AddView(ViewLastWinningNumber, viewLastWinningNumberThunk)

	for i, key := range keyMap {
		idxMap[i] = key.KeyId()
	}
}

type FuncLockBetsContext struct {
	State FairRouletteFuncState
}

func funcLockBetsThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcLockBets")
	// only SC itself can invoke this function
	ctx.Require(ctx.Caller() == ctx.AccountId(), "no permission")

	f := &FuncLockBetsContext{
		State: FairRouletteFuncState{
			stateId: wasmlib.GetObjectId(1, wasmlib.KeyState, wasmlib.TYPE_MAP),
		},
	}
	funcLockBets(ctx, f)
	ctx.Log("fairroulette.funcLockBets ok")
}

type FuncPayWinnersContext struct {
	State FairRouletteFuncState
}

func funcPayWinnersThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcPayWinners")
	// only SC itself can invoke this function
	ctx.Require(ctx.Caller() == ctx.AccountId(), "no permission")

	f := &FuncPayWinnersContext{
		State: FairRouletteFuncState{
			stateId: wasmlib.GetObjectId(1, wasmlib.KeyState, wasmlib.TYPE_MAP),
		},
	}
	funcPayWinners(ctx, f)
	ctx.Log("fairroulette.funcPayWinners ok")
}

type FuncPlaceBetParams struct {
	Number wasmlib.ScImmutableInt64 // the number a better bets on
}

type FuncPlaceBetContext struct {
	Params FuncPlaceBetParams
	State  FairRouletteFuncState
}

func funcPlaceBetThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcPlaceBet")
	p := ctx.Params().MapId()
	f := &FuncPlaceBetContext{
		Params: FuncPlaceBetParams{
			Number: wasmlib.NewScImmutableInt64(p, idxMap[IdxParamNumber]),
		},
		State: FairRouletteFuncState{
			stateId: wasmlib.GetObjectId(1, wasmlib.KeyState, wasmlib.TYPE_MAP),
		},
	}
	ctx.Require(f.Params.Number.Exists(), "missing mandatory number")
	funcPlaceBet(ctx, f)
	ctx.Log("fairroulette.funcPlaceBet ok")
}

type FuncPlayPeriodParams struct {
	PlayPeriod wasmlib.ScImmutableInt64 // number of minutes in one playing round
}

type FuncPlayPeriodContext struct {
	Params FuncPlayPeriodParams
	State  FairRouletteFuncState
}

func funcPlayPeriodThunk(ctx wasmlib.ScFuncContext) {
	ctx.Log("fairroulette.funcPlayPeriod")
	// only SC creator can update the play period
	ctx.Require(ctx.Caller() == ctx.ContractCreator(), "no permission")

	p := ctx.Params().MapId()
	f := &FuncPlayPeriodContext{
		Params: FuncPlayPeriodParams{
			PlayPeriod: wasmlib.NewScImmutableInt64(p, idxMap[IdxParamPlayPeriod]),
		},
		State: FairRouletteFuncState{
			stateId: wasmlib.GetObjectId(1, wasmlib.KeyState, wasmlib.TYPE_MAP),
		},
	}
	ctx.Require(f.Params.PlayPeriod.Exists(), "missing mandatory playPeriod")
	funcPlayPeriod(ctx, f)
	ctx.Log("fairroulette.funcPlayPeriod ok")
}

type ViewLastWinningNumberResults struct {
	LastWinningNumber wasmlib.ScMutableInt64
}

type ViewLastWinningNumberContext struct {
	Results ViewLastWinningNumberResults
	State   FairRouletteViewState
}

func viewLastWinningNumberThunk(ctx wasmlib.ScViewContext) {
	ctx.Log("fairroulette.viewLastWinningNumber")
	r := ctx.Results().MapId()
	f := &ViewLastWinningNumberContext{
		Results: ViewLastWinningNumberResults{
			LastWinningNumber: wasmlib.NewScMutableInt64(r, idxMap[IdxResultLastWinningNumber]),
		},
		State: FairRouletteViewState{
			stateId: wasmlib.GetObjectId(1, wasmlib.KeyState, wasmlib.TYPE_MAP),
		},
	}
	viewLastWinningNumber(ctx, f)
	ctx.Log("fairroulette.viewLastWinningNumber ok")
}
