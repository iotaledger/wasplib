// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
//////// DO NOT CHANGE THIS FILE! ////////
// Change the json schema instead

//@formatter:off

#![allow(dead_code)]

use fairroulette::*;
use wasmlib::*;
use wasmlib::host::*;

use crate::consts::*;
use crate::keys::*;
use crate::state::*;

mod consts;
mod keys;
mod state;
mod types;
mod fairroulette;

#[no_mangle]
fn on_load() {
    let exports = ScExports::new();
    exports.add_func(FUNC_LOCK_BETS, func_lock_bets_thunk);
    exports.add_func(FUNC_PAY_WINNERS, func_pay_winners_thunk);
    exports.add_func(FUNC_PLACE_BET, func_place_bet_thunk);
    exports.add_func(FUNC_PLAY_PERIOD, func_play_period_thunk);
    exports.add_view(VIEW_LAST_WINNING_NUMBER, view_last_winning_number_thunk);
    unsafe {
        for i in 0..KEY_MAP_LEN {
            IDX_MAP[i] = get_key_id_from_string(KEY_MAP[i]);
        }
    }
}

pub struct FuncLockBetsContext {
    state: FairRouletteFuncState,
}

fn func_lock_bets_thunk(ctx: &ScFuncContext) {
    ctx.log("fairroulette.funcLockBets");
    // only SC itself can invoke this function
    ctx.require(ctx.caller() == ctx.account_id(), "no permission");

    let f = FuncLockBetsContext {
        state: FairRouletteFuncState {
            state_id: get_object_id(1, KEY_STATE.get_key_id(), TYPE_MAP),
        },
    };
    func_lock_bets(ctx, &f);
    ctx.log("fairroulette.funcLockBets ok");
}

pub struct FuncPayWinnersContext {
    state: FairRouletteFuncState,
}

fn func_pay_winners_thunk(ctx: &ScFuncContext) {
    ctx.log("fairroulette.funcPayWinners");
    // only SC itself can invoke this function
    ctx.require(ctx.caller() == ctx.account_id(), "no permission");

    let f = FuncPayWinnersContext {
        state: FairRouletteFuncState {
            state_id: get_object_id(1, KEY_STATE.get_key_id(), TYPE_MAP),
        },
    };
    func_pay_winners(ctx, &f);
    ctx.log("fairroulette.funcPayWinners ok");
}

pub struct FuncPlaceBetParams {
    pub number: ScImmutableInt64, // the number a better bets on
}

pub struct FuncPlaceBetContext {
    params: FuncPlaceBetParams,
    state:  FairRouletteFuncState,
}

fn func_place_bet_thunk(ctx: &ScFuncContext) {
    ctx.log("fairroulette.funcPlaceBet");
    let p = ctx.params().map_id();
    let f = FuncPlaceBetContext {
        params: FuncPlaceBetParams {
            number: ScImmutableInt64::new(p, idx_map(IDX_PARAM_NUMBER)),
        },
        state: FairRouletteFuncState {
            state_id: get_object_id(1, KEY_STATE.get_key_id(), TYPE_MAP),
        },
    };
    ctx.require(f.params.number.exists(), "missing mandatory number");
    func_place_bet(ctx, &f);
    ctx.log("fairroulette.funcPlaceBet ok");
}

pub struct FuncPlayPeriodParams {
    pub play_period: ScImmutableInt64, // number of minutes in one playing round
}

pub struct FuncPlayPeriodContext {
    params: FuncPlayPeriodParams,
    state:  FairRouletteFuncState,
}

fn func_play_period_thunk(ctx: &ScFuncContext) {
    ctx.log("fairroulette.funcPlayPeriod");
    // only SC creator can update the play period
    ctx.require(ctx.caller() == ctx.contract_creator(), "no permission");

    let p = ctx.params().map_id();
    let f = FuncPlayPeriodContext {
        params: FuncPlayPeriodParams {
            play_period: ScImmutableInt64::new(p, idx_map(IDX_PARAM_PLAY_PERIOD)),
        },
        state: FairRouletteFuncState {
            state_id: get_object_id(1, KEY_STATE.get_key_id(), TYPE_MAP),
        },
    };
    ctx.require(f.params.play_period.exists(), "missing mandatory playPeriod");
    func_play_period(ctx, &f);
    ctx.log("fairroulette.funcPlayPeriod ok");
}

pub struct ViewLastWinningNumberResults {
    pub last_winning_number: ScMutableInt64,
}

pub struct ViewLastWinningNumberContext {
    results: ViewLastWinningNumberResults,
    state:   FairRouletteViewState,
}

fn view_last_winning_number_thunk(ctx: &ScViewContext) {
    ctx.log("fairroulette.viewLastWinningNumber");
    let r = ctx.results().map_id();
    let f = ViewLastWinningNumberContext {
        results: ViewLastWinningNumberResults {
            last_winning_number: ScMutableInt64::new(r, idx_map(IDX_RESULT_LAST_WINNING_NUMBER)),
        },
        state: FairRouletteViewState {
            state_id: get_object_id(1, KEY_STATE.get_key_id(), TYPE_MAP),
        },
    };
    view_last_winning_number(ctx, &f);
    ctx.log("fairroulette.viewLastWinningNumber ok");
}

//@formatter:on
