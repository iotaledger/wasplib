// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

package generator

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
)

type Generator struct {
	schema *JsonSchema
}

var ModuleCwd string
var ModuleName string
var ModulePath string

var camelRegExp = regexp.MustCompile("_[a-z]")
var snakeRegExp = regexp.MustCompile("[a-z0-9][A-Z]")

// convert lowercase snake case to camel case
func camel(name string) string {
	return camelRegExp.ReplaceAllStringFunc(name, func(sub string) string {
		return strings.ToUpper(sub[1:])
	})
}

// capitalize first letter
func capitalize(name string) string {
	return upper(name[:1]) + name[1:]
}

func copyright(noChange bool) string {
	text := "// Copyright 2020 IOTA Stiftung\n" +
		"// SPDX-License-Identifier: Apache-2.0\n"
	if noChange {
		text += "\n// (Re-)generated by schema tool\n" +
			"//////// DO NOT CHANGE THIS FILE! ////////\n" +
			"// Change the json schema instead\n"
	}
	return text
}

// convert to lower case
func lower(name string) string {
	return strings.ToLower(name)
}

func FindModulePath() error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	// we're going to walk up the path, make sure to restore
	ModuleCwd = cwd
	defer os.Chdir(ModuleCwd)

	file, err := os.Open("go.mod")
	for err != nil {
		err = os.Chdir("..")
		if err != nil {
			return fmt.Errorf("cannot find go.mod in cwd path")
		}
		cwd, err = os.Getwd()
		if err != nil {
			return err
		}
		file, err = os.Open("go.mod")
	}

	// now file is the go.mod and cwd holds the path
	defer file.Close()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "module ") {
			ModuleName = strings.TrimSpace(line[len("module"):])
			ModulePath = cwd
			return nil
		}
	}

	return fmt.Errorf("cannot find module definition in go.mod")
}

// pad to specified size with spaces
func pad(name string, size int) string {
	for i := len(name); i < size; i++ {
		name += " "
	}
	return name
}

// convert camel case to lower case snake case
func snake(name string) string {
	return lower(snakeRegExp.ReplaceAllStringFunc(name, func(sub string) string {
		return sub[:1] + "_" + sub[1:]
	}))
}

// convert to upper case
func upper(name string) string {
	return strings.ToUpper(name)
}

func sortedFields(dict FieldMap) []string {
	keys := make([]string, 0)
	for key := range dict {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

func sortedKeys(dict StringMap) []string {
	keys := make([]string, 0)
	for key := range dict {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

func sortedMaps(dict StringMapMap) []string {
	keys := make([]string, 0)
	for key := range dict {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}
